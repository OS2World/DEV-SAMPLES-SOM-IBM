/*
 *
 *  25H7912  (C)  COPYRIGHT International Business Machines Corp. 1992,1996,1996
 *  All Rights Reserved
 *  Licensed Materials - Property of IBM
 *  US Government Users Restricted Rights - Use, duplication or
 *  disclosure restricted by GSA ADP Schedule Contract with IBM Corp.
 *
 *
 *
 *  DISCLAIMER OF WARRANTIES.
 *  The following [enclosed] code is sample code created by IBM
 *  Corporation. This sample code is not part of any standard or IBM
 *  product and is provided to you solely for the purpose of assisting
 *  you in the development of your applications.  The code is provided
 *  "AS IS". IBM MAKES NO WARRANTIES, EXPRESS OR IMPLIED, INCLUDING BUT
 *  NOT LIMITED TO THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
 *  FOR A PARTICULAR PURPOSE, REGARDING THE FUNCTION OR PERFORMANCE OF
 *  THIS CODE.  IBM shall not be liable for any damages arising out of
 *  your use of the sample code, even if they have been advised of the
 *  possibility of such damages.
 *
 *  DISTRIBUTION.
 *  This sample code can be freely distributed, copied, altered, and
 *  incorporated into other software, provided that it bears the above
 *  Copyright notice and DISCLAIMER intact.
 *
 */

#ifndef lint
static char *sccsid = "%Z% %I% %W% %G% %U% [%H% %T%]";
#endif

/*
 * CLIENT2.CPP
 *
 *  NOTE
 *     Please read the README file before inspecting this code. It provides
 *  a context to enhance your understanding of how the Externalization
 *  Service can be used to your advantage.
 *
 *  DESCRIPTION:
 *     Client2.exe is a sample that uses Externalization Service and IBM
 *  extensions to optimally minimize the transfer overhead associated with
 *  instanciating a local instance of a remote object.  The remote method
 *  dispatches associated  the somStream::Streamable when internalized are
 *  avoided.  The distinctive elements of client2's algorithm can be seen
 *  by comparing it to the algorithm of client1.
 *
 * CONTRAST THE ALGORITHMS OF CLIENT1 AND CLIENT2 SAMPLES
 *           CLIENT 1                             CLIENT 2
 *     1. Create remote object                Create remote object
 *
 *     2. Create local stream                 Create local stream
 *
 *     3.                                     Create remote stream
 *
 *     4. Externalize remote object           Externalize remote object
 *        into a stream on the LOCAL          into a stream on the REMOTE
 *        server thread.                      server.
 *
 *     5.                                     Get the buffer from the streamIO of
 *                                            the remote stream.
 *
 *     6.                                     Set the buffer of the remote
 *                                            streamIO to the buffer of the
 *                                            local stream streamIO.
 *
 *     7. Internalize the local stream        Internalize the local stream into
 *        into a local object                 into a local object.
 *
 *     8. Process the local object.           Process the local object.
 *
 *     end algorithm                       end algorithm
 *
 * NOTE: Client 2 performs 3 additional steps (3, 5, and 6).  These steps are
 *       indicated in the code below by  markers ( #3#, #5#, or #6#).
 *
 *       The difference in step 4 is also important. Client2's algorithm eliminates
 *       the remote dispatches generated by the externalization of the remote object
 *       into a local stream.
 *
 */


#include <iostream.h>
#include <somd.xh>

#include <somestrm.xh>  // Usage bindings for Externalization
#include <somestio.xh>

#include "util.hpp"     // Utilities for the samples
#include "samobj.xh"    // Usage bindings of sample object


/*
   This sample uses streams identified by the following string. Streams
of this type support the streaming of stringified object references
to the streamIO buffer of the stream. (shallow copy)
*/
#define STRM_CLASS           "somExternalization::OSStream"

/*
   Streams always contain a streamIO object.  Choosing the streamIO type
determines how object state values are represented in the streamIO buffer
when an object is externalized.  The string "somStream::StringStreamIO" is
used to choose the string representation of object state values in the
streamIO buffer.
*/
#define STRM_IO_CLASS        "somStream::StringStreamIO"

void main(int argc, char **argv) {
  Environment                      *ev = somGetGlobalEnvironment();
  somExternalization_StreamFactory *localStrmFactory, *remoteStrmFactory;
  SOMDServer                       *srvThread, *objSvr;
  somLifeCycle_FactoryFinder       *ff;
  somExternalization_Stream        *localStrm, *remoteStrm;
  somStream_seq_octet              buf; // Copy of remote streamIO buffer
  OESSample_Department             *remoteObject,
                                   *localObject;

  SOMD_Init(ev);
  startServerThread();

// Create the stream in this process
  localStrmFactory  = (somExternalization_StreamFactory *) (void *)
     new somExternalization_StreamFactory;
  localStrm =  (somExternalization_OSStream *) (void *)
     localStrmFactory->create_with_types(ev,
                                    ((string) "somExternalization::OSStream"),
                                    ((string)"somStream::StringStreamIO"));

// #3# Create the stream on the remote object server
  remoteStrmFactory  = (somExternalization_StreamFactory *) ((void *)
     somdCreate(ev,"somExternalization::StreamFactory", TRUE));
  remoteStrm =  remoteStrmFactory->create_with_types(ev, STRM_CLASS, STRM_IO_CLASS );

// Get a reference to the remote object.
  remoteObject = getRemoteObjectReference();

// Store the remote object's state into the remote stream's streamIO buffer.
  remoteStrm->externalize(ev,remoteObject);

// Fetch the streamIO buffer from the remote stream and put it into
// the streamIO of the local stream
/*#5#*/   buf = remoteStrm->_get_streamio(ev)->get_buffer(ev);
/*#6#*/   localStrm->_get_streamio(ev)->set_buffer(ev, &buf);

// Create a local object for processing. The created factory finder (ff)
// causes the object to be created on the local server thread via the
// internalize call.
  ff =  createMyFF();
  localObject = (OESSample_Department *) localStrm->internalize(ev,ff);

// Perform processing using the local object
  OESSample_SalesValues   *sales  = localObject->_get_sales(ev);
  OESSample_CompanyCounts *counts = localObject->_get_counts(ev);
  long                    count   = counts->getCount(ev,DEPT45);
  float                   sum     = 0.0;
  long                    c;

  for(c = 0; c < count; ++c)
     sum += sales->getSale(ev);

  cout << "\n\tThe mean of the sales is " << sum/(float)count << endl;
  cout << "\n\n\n******* RUN COMPLETE ********\n\n\n" << endl;

  // Perform cleanup
  ORBfree(localStrm);
  checkException(ev, "Client2 -- Freeing the local stream");

  ORBfree(remoteStrm);
  checkException(ev, "Client2 -- Freeing the remote stream");

  SOMFree(buf._buffer);   // Return memory allocated via the get_buffer() call

  ((SOMDObject *)remoteObject)->release(ev);
  checkException(ev, "Client2 -- Release the romote object");

  localObject->uninit_for_object_destruction(ev);
  checkException(ev, "Client2 -- Unititializing the local object");
  ORBfree(localObject);
  checkException(ev, "Client2 -- Freeing the local object");

  ((somLifeCycle_ServerSetLocation *)ff->get_location_scope(ev))
     ->uninit_for_object_destruction(ev);
     checkException(ev, "Client2 -- Uninitializing the location object");
  ORBfree(ff->get_location_scope(ev));
  checkException(ev, "Client2 -- Freeing the location object\n");

  ff->uninit_for_object_destruction(ev);
  checkException(ev, "Client2 -- Uninitializing the factory finder object");
  ORBfree(ff);
  checkException(ev, "Client2 -- Freeing the factory finder object");


     SOMD_Uninit(ev);
}



