<HTML><TITLE>Title</TITLE>
<BODY>

<P>
<P>
<P>
<P>
<P>
<P>
<P>
<P>
<P>
<P>
<P>
<P>
<P>
<P>
<P>
<CENTER><B><P>
<P>
BaseNonContainer<P>
Programming Guide and Framework Reference<P>
</CENTER><P>
<CENTER><P>
</CENTER><P>
<P>
<P>
<P>
<P>
<P>
<P>
<P>
<P>
<P>
<P>
<P>
<P>
<P>
<P>
<P>
<CENTER></B><I>Joseph H McIntyre</I><P>
IBM Corporation<P>
</CENTER><P>
<P>
<P>
<P>
<P>
<P>
<P>
<P>
<P>
<P>
Before using the information, and the product it supports, be sure to read the general information under Appendix A, &quot;Notices&quot;.<P>
<P>
<P>
<P>
<P>
<P>
<P>
<P>
<P>
<P>
<P>
<P>
<P>
<P>
<P>
<P>
<P>
<P>
<P>
The following paragraph does not apply to the United Kingdom or any country where such provisions are inconsistent with local law. INTERNATIONAL BUSINESS MACHINES CORPORATION PROVIDES THIS PUBLICATION &quot;AS IS&quot; WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE. Some states do not allow disclaimer of express or implied warranties in certain transactions, therefore, this statement may not apply to you.<P>
<P>
This publication could include technical inaccuracies or typographical errors. Changes are periodically made to the information herein; these changes will be incorporated in new editions of the publication. IBM may make improvements and/or changes in the product(s) and/or the program(s) described in this publication at any time.<P>
<P>
It is possible that this publication may contain reference to, or information about, IBM products (machines and programs), programming, or services that are not announced in your country. Such references or information must not be construed to mean that IBM intends to announce such IBM products, programming, or services in your country.<P>
<P>
Requests for technical information about IBM products should be made to your IBM reseller or IBM marketing representative.<P>
<P>
(c) Copyright International Business Machines Corporation 1996. All rights reserved.<P>
<P>
Note to U.S. Government users - Documentation related to restricted rights - Use, duplication or disclosure is subject to restrictions set forth in GSA ADP Schedule Contract with IBM Corp.<P>
<B>Pre-release notification<P>
</B><P>
This document is to be considered a living document and work-in-progress at the current time. As long as this notice is here, consider the information contained within the document to be useful but preliminary in nature. <P>
<P>
<P>
<H1>Part Lifecycle<B></H1>
</B><P>
Since OpenDoc parts are SOM objects, there are two initialization and termination sequences of interest, that of the SOM object and of the component startup and shutdown.<P>
<P>
When a SOM object is created, an initializer is called. SOMDefaultInit is the default initializer, though others can be defined and used. It is appropriate in this method to set initial values for attributes and private variables, however memory allocations should be held until the component initialization when error handling can be done more easily. Note, earlier versions of SOM used a method, SOMInit, however this method is obsolete and should not be used (all code in this book and generated by PartMeister does not use SOMInit). <P>
<P>
When a SOM object is destroyed, a destructor is called. SOMDestruct is an appropriate place to release allocated memory and free any other resources associated with the object. It is the last method called before the object is destroyed. Note, this method is a match to the new initializer - the obsolete SOMInit used the now obsolete method SOMUninit as its destructor.<P>
<P>
An OpenDoc component has two initialization methods, InitPart and InitPartFromStorage. If an component is being created for the first time then InitPart is called. InitPart should completely setup the component. If, however, a component is being reloaded (it has been stored persistently), then InitPartFromStorage is called instead of InitPart. The component should use the information from the persistent store to setup the component such that it reflects the state in which it was stored.<P>
<P>
<H2><B>Initialization</H2>
<H3>Initialization during the registration process</B></H3>
<P>
On OS/2, when a component is registered it will be instansiated (calling InitPart). When the icon is created on the desktop or in a folder, it will actually be a document consisting of that part. Thus when the user uses drag-and-drop to create an instance of the component in an OpenDoc application, InitPartFromStorage will be called, as the icon has persistent storage associated with it from the registration process.<P>
<P>
<H3><B>Initialization during creation of a root part</B></H3>
<P>
When a root part is created, the initialization cycle follows through the process for creating a new part (SOM object initialization, OpenDoc InitPart), externalization then through the InitPartFromStorage process. Therefore, it is important that an object does not have any dependencies on either InitPart or InitPartFromStorage.<P>
<P>
<H3><B>Initialization when a part is dragged from a template into an application</B></H3>
<P>
When a part is added to an application using drag and drop from a template, the part will be initialized using InitPartFromStorage since the creation of the template during the registration process creates a default part state with content defined in the InitPart processing.<P>
<P>
<H3><B>Initialization when a stored application is loaded</B></H3>
<P>
When an application is loaded from a file, the initialization restores the application to its last saved state. A significant difference is that frames are not created, they are restored. This changes the initialization process to use the method DisplayFrameConnected instead of DisplayFrameAdded. The primary difference between the two methods is that DisplayFrameAdded will create a new FramePartInfo object, whereas DisplayFrameConnected will use the FramePartInfo objects that is restored with the part. Other processing, such as making the frame available as a drop target must be done in both methods.<P>
<B>Externalization<P>
</B><P>
Externalization simply means storing the component data and state. A component should store enough information such that is can reproduce itself when the user accesses this instance again.<P>
<P>
OpenDoc may be used in a heterogeneous, distributed environment - and it is likely that all the users will have access to the same software or configurations, especially if one thinks about the ability to send information across the Internet. Thus, the ability to reproduce the saved state on a foreign system requires some additional considerations - for example, a particular word processor may not exist for the platform on which a document is received, but this should not preclude that user from viewing the document.<P>
<P>
One of the OpenDoc technologies, Bento, provides mechanisms that allow OpenDoc applications to store their content flexibly to allow users to share information easily in a distributed environment. A component may store its content in any number of representations, allowing the creator to indicate the set of representations that are required (flexibility with user control), and the receivers to view the content with their own choice of content editor or viewer (user customization). <P>
<P>
For example, a word processing document could be created on OS/2 Warp with ABC Writer and embed a photo using ABC PhotoEditor. The creator chooses to store the document using the native ABC file formats, as well as RTF for the text and JPEG for the photo. The document could be sent to a Mac OS user, where ABC has not yet ported its software. The Mac OS user loads the RTF version of the document into DEF WP, and the JPEG version of the photo into DEF Photo.<P>
<H1><B>Internalization and Externalization Frameworks</H1>
</B><P>
Storing are restoring the state and contents of part handlers involves managing a number of standard entries in addition to the data content for the part itself. The internalization and externalization frameworks are designed to minimize the effort of the developer to managing the content of the part handler which is unique to the part under development. For most part handlers, the developer will require only implementing the two 'content' methods to satisfy data input/output requirements.<P>
<P>
These two frameworks rely on a derived class to implement the method PartKind, which returns the ISO string that identifies this part handler. It is mandatory to override this method unless the entire internalization and externalization frameworks are replaced.<B><P>
<P>
<H2>Internalization Framework</H2>
</B><P>
This framework provides an initialization process that divides the state and content internalization. The state is often not overridden, as it handles the restoration of display frames.<P>
<P>
This allows the developer to concentrate on the restoration of the part content by augmenting the InternalizeContent method. The parent method should be called first, then the derived method may extract the content from the storage unit as desired. Augmentation is recommended as the parent classes may store content independent of the derived part.<P>
<P>
For developers creating parts that may be derived from, ensure that unique data type identifiers are used for non-standard data types, and that standard types are not stored privately - as they may be overridden by a derived class.<P>
<B><P>
<H2>Externalization Framework</B></H2>
<P>
This framework manages the sequence of methods for storing state and content through four methods - ClearContentsProperty, ExternalizeHeader, ExternalizeState, ExternalizeContent.<P>
<P>
ClearContentsProperty removes any kODPropContents property that does not match the derived parts kind. This ensures that the storage unit contains a single kODPropContents property, and it represents the currently active part handler.<P>
<P>
ExternalizeHeader populates the storage unit with kODPropContents and kODPreferredEditor properties. This method will rarely be subclassed.<P>
<P>
ExternalizeState stores the current part state including display frames.<P>
<P>
ExternalizeContent will usually be augmented by the derived part, calling the parent method first and then adding additional content to the storage unit to reflect the derived parts content.<P>
<H1>Data Transfer and Persistent Storage</H1>
<P>
OpenDoc provides a single mechanism for packaging data, regardless of what operation will be applied to the data. This mechanism is the storage unit. For clipboard, drag, drop, linking and persistence, the developer populates or retrieves data using the same classes and methods.<P>
<P>
A storage unit is a hierarchy of properties and associated values. Each property may contain zero or more values, with each value having a single data type. A hierarchy may be implemented by having a value reference another property. The storage unit is an abstraction, it does not have any dependence on a particular device, source or target. This allows the implementation of persistent storage, cross-process and cross-network data transfers and future technologies to be implemented transparent to the application utilizing the service. It also provides a mechanism where applications can store and retrieve data without any proprietary format knowledge required for standard data types (a storage unit may contain values that are stored in a proprietary format, but may also contain alternate standard formats).<P>
<P>
Consider a word processing application being used to create an email message where the recipients of the message will be using the same word processor. The sender does not need to be concerned with the format in which the message is stored. However, if the sender is not sure of all the recipients word processing packages, then a standard format such as ASCII text or RTF may be used - even if it means the loss of fidelity in the presentation of the message. Storage units provide a solution for this case, the property (the message in this case) may contain many values, each of a different data type. For instance,<P>
<P>
<TABLE BORDER=1><TD  VALIGN=TOP>Property<TD  VALIGN=TOP>Message<TR>
<TD  VALIGN=TOP>Value<TD  VALIGN=TOP>Word Processor specific (native format)<TR>
<TD  VALIGN=TOP>Value<TD  VALIGN=TOP>Rich text format (RTF)<TR>
<TD  VALIGN=TOP>Value<TD  VALIGN=TOP>Plain text (ASCII)</TABLE>
<P>
The recipient on receiving the message will use the highest fidelity version of the message, thus a user with the same word processor will see the Word Processor specific version, the use with a different word processor that cannot read the native format will use the RTF version and the user that does not have a word processor that can read either of these (for instance a text editor) will see the ASCII text version.<P>
<P>
The addition of translators, that can provide on-the-fly translation from one format to another can also assist with this process. For example, the native format for a word processor may have translators to the native format for another word processor. This would likely have higher fidelity than going to RTF, and would deliver the message in a manner suited specifically to the user's installed word processor.<P>
<P>
<H2><B>Data Transfer - Clipboard, Drag/Drop and Linking</B></H2>
<P>
The transfer of data between components usually is similar for each of the standard data transfer mechanisms. For example, a word processor will usually provide the same content, currently selected text, for all data transfer operations.<P>
<P>
The actual transfer processes, when described as operations to a user, are very similar - even though in current GUI API sets they are usually implemented in very different ways using different APIs and messages. OpenDoc provides a set of methods that implement all data transfers using storage units, with some of the similarity of operation abstracted. However, a framework that implements a uniform interface for these operations is not provided in the base toolkit - but is provided in the next section.<P>
<P>
<P>
<H2><B>Data Transfer Framework - Clipboard, Drag/Drop, Link Source, Link Target</B></H2>
<P>
The following is the general implementation for this framework; methods are provided for,<P>
<P>
return true/false indicating whether the operation is valid<P>
populate a storage unit with content to be transferred<P>
extract content from a received storage unit<P>
<P>
Additional methods, specific to the operation, are provided to manage the differences in user operation for the different transfer types - for instance, you may specify an icon to use for drag operations. However, these operation specific methods are minimal and default behavior is provided that makes implementation of these methods optional.<P>
<P>
<H3><B>Clipboard</B></H3>
<P>
The clipboard operations are invoked through menu selections from the Edit menu and keyboard accelerators for those menu items. Each of the operations - cut, copy, paste - is implemented in the framework.<P>
<P>
Validity checking is provided with the methods MenuCutValid, MenuCopyValid and MenuPasteValid. Before an accelerator is dispatched to the clipboard operation or the Edit menu is displayed, the appropriate method will be called. If kODTrue is returned, the operation will be carried out or the menu item will be enabled. If kODFalse is returned, the operation will not be dispatched or the menu item will be disabled.<P>
<P>
If an operation is dispatched the appropriate method, MenuCut, MenuCopy or MenuPaste will be called. <P>
<P>
MenuCut should be overridden and act on its content appropriately.<P>
<P>
MenuCopy will rarely be overridden, as its operation will dispatch the method PopulateClipboardStorageUnit which is usually the only action required of a component.<P>
<P>
MenuPaste will rarely be overridden, as its operation will dispatch the method ReceiveClipboardStorageUnit which is usually the only action required of a component.<P>
<P>
PopulateClipboardStorageUnit is called with a storage unit that is prepared for placement on the clipboard. The component adds its properties to the storage unit and returns. A component may choose to use a promise instead of putting the content in the storage unit, and implement the FulfillPromise method as appropriate.<P>
<P>
ReceiveClipboardStorageUnit is called with the storage unit that has been received from the clipboard. The component may extract the information it desires and return. Whether the content is received as the result of a promise is transparent to the developer.<P>
<P>
<H3><B>Drag</B></H3>
<P>
DragValid is called when the user tries to initiate a drag operation, indicating whether this action is currently valid.<P>
<P>
DropValid is called, with a storage unit, when the user moves the icon for a current drag operation over the component. The component may check the current contents of the storage unit to determine whether any of the content is valid to drop on this component. Each frame, when it is setup, will call this method with a null storage unit - the method should return kODTrue if a drop is ever valid for this frame.<P>
<P>
Drag is called when the user initiates a drag operation (assuming DragValid returns kODTrue). When the user starts the drag, AcquireDragPointer will be called, allowing the part to provide its own icon for the drag action. The drag storage unit will also be populated, or a promise made.<P>
<P>
Drop is overridden from ODPart and given default function that will call ReceiveDropStorageUnit with the storage unit from the drop action.<P>
<P>
PopulateDragStorageUnit is called with a storage unit that is prepared for the drag operation. The component adds its properties to the storage unit and returns. A component may choose to use a promise instead of putting the content in the storage unit, and implement the FulfillPromise method as appropriate.<P>
<P>
ReceiveDropStorageUnit is called with the storage unit that has been received as a result of a drop action. The component may extract the information it desires and return. Whether the content is received as the result of a promise is transparent to the developer.<P>
<P>
<H3><B>Link Source</B></H3>
<P>
LinkSourceValid is called when the user initiates a link action (may be through a direct manipulation action or the use of the Copy item from the Edit menu, which will place a link specification on the clipboard). If this method returns kODTrue, the link specification will be requested and link source set up.<P>
<P>
PopulateLinkSpec allows the component to define the specification information that indicates the content to be linked. The default is a null specifier, indicating a single content value will be the source content.<P>
<P>
UpdateLink is invoked by the component when the content changes.<P>
<P>
PopulateLinkStorageUnit is called when the framework is ready to post an update to the content.<P>
<B><P>
<H3>Link Target</B></H3>
<P>
ReceiveLinkStorageUnit delivers the storage unit containing the updated data from the attached link source.<P>
<H3><B>Clipboard framework reference</B></H3>
<TABLE BORDER=1><TD  VALIGN=TOP>MenuCutValid<TD  VALIGN=TOP>return kODTrue/kODFalse indicating whether Cut operation is currently valid. Result returned in framework is kODFalse.<TR>
<TD  VALIGN=TOP>MenuCopyValid<TD  VALIGN=TOP>return kODTrue/kODFalse indicating whether Copy operation is currently valid. Result returned in framework is kODFalse.<TR>
<TD  VALIGN=TOP>MenuPasteValid<TD  VALIGN=TOP>return kODTrue/kODFalse indicating whether Paste operation is currently valid. Result returned in framework is kODFalse.<TR>
<TD  VALIGN=TOP>MenuCut<TD  VALIGN=TOP>implementation of cut operation. Framework has no implementation.<TR>
<TD  VALIGN=TOP>MenuCopy<TD  VALIGN=TOP>implementation of copy operation. Framework prepares a storage unit for placement on the clipboard, sets up the focus for the clipboard and populates the clipboard with the storage unit populated by the PopulateClipboardStorageUnit method.<TR>
<TD  VALIGN=TOP>MenuPaste<TD  VALIGN=TOP>implementation of paste operation. Framework receives the storage unit from the clipboard and calls the method ReceiveClipboardStorageUnit to parse the content.<TR>
<TD  VALIGN=TOP>PopulateClipboardStorageUnit<TD  VALIGN=TOP>place content, or promise, into storage unit to be placed on clipboard. Framework has no implementation.<TR>
<TD  VALIGN=TOP>ReceiveClipboardStorageUnit<TD  VALIGN=TOP>extract content from storage unit received from clipboard. Framework has no implementation.</TABLE>
<P>
<H3><B>Drag/Drop framework reference</B></H3>
<TABLE BORDER=1><TD  VALIGN=TOP>DragValid<TD  VALIGN=TOP>return kODTrue/kODFalse, indicates whether drag action is valid. Result returned in framework is kODFalse.<TR>
<TD  VALIGN=TOP>AcquireDragPointer<TD  VALIGN=TOP>return icon to use as the displayed pointer for the drag operation. The framework provides a default icon.<TR>
<TD  VALIGN=TOP>Drag<TD  VALIGN=TOP>implementation of the drag action. Framework initiates drag, calling AcquireDragPointer and PopulateDragStorageUnit.<TR>
<TD  VALIGN=TOP>PopulateDragStorageUnit<TD  VALIGN=TOP>place content, or promise, into storage unit to be dragged. Framework has no implementation.<TR>
<TD  VALIGN=TOP>DropValid<TD  VALIGN=TOP>return kODTrue/kODFalse, indicates whether drop action is valid for the content provided in the storage unit. When a frame is instansiated, it will call this method with a kODNULL storage unit, the response should indicate whether a drop operation is ever valid for this frame.<TR>
<TD  VALIGN=TOP>Drop<TD  VALIGN=TOP>Overridden from ODPart, provides mechanism for handling the drop action and dispatching the ReceiveDropStorageUnit method.<TR>
<TD  VALIGN=TOP>ReceiveDropStorageUnit<TD  VALIGN=TOP>extract content from storage unit dropped. Framework has no implementation.</TABLE>
<P>
<H3><B>Linking framework reference</B></H3>
<TABLE BORDER=1><TD  VALIGN=TOP>LinkSourceValid<TD  VALIGN=TOP>return kODTrue/kODFalse, indicates whether the part can be a link source in current context. Result returned in framework is kODFalse.<TR>
<TD  VALIGN=TOP>PopulateLinkStorageUnit<TD  VALIGN=TOP>place content, or promise, into storage unit to be transferred. Framework has no implementation.<TR>
<TD  VALIGN=TOP>UpdateLink<TD  VALIGN=TOP>method is only called by derived part, to indicate that the content has changed. The framework calls PopulateLinkStorageUnit for each attached link target.<TR>
<TD  VALIGN=TOP>RecieveLinkStorageUnit<TD  VALIGN=TOP>extract content from storage unit. Framework has no implementation.</TABLE>
Draw Framework<P>
<P>
The Draw framework provides basic support for the four view types supported by OpenDoc - small icon, large icon, thumbnail and frame. Menu support is enabled for the Show As menu items, and the commands are handled in the HandleEvent method to dispatch the appropriate calls to change the view type.<P>
<P>
According to the current view type, an appropriate draw method will be called. The implementation of the thumbnail is as a very large icon, since the base class has no content to represent in a miniature representation.<P>
<H1>Appendix A: Notices</H1>
<P>
References in this publication to IBM products, programs, or services do not imply that IBM intends to make these available in all countries in which IBM operates. Any reference to an IBM product, program, or service is not intended to state or imply that only that IBM product, program, or service may be used. Subject to IBM's valid intellectual property or other legally protectable rights, any functionally equivalent product, program, or service may be used instead of the IBM product, program, or service. The evaluation and verification of the operation in conjunction with other products, except those expressly designated by IBM, are the responsibility of the user.<P>
<P>
IBM may have patents or pending patent applications covering subject matter in this document. The furnishing of this document does not give you any license to these patents. You can send license inquiries, in writing, to:<P>
IBM Director of Licensing<P>
IBM Corporation<P>
500 Columbus Avenue<P>
Thornwood, NY 10594<P>
U.S.A.<P>
<P>
Licencees of this program who wish to have information about it for purposes of enabling: (i) the exchange of information between independently created programs and other programs (including this one) and (ii) the mutual use of the information which has been exchanged, should contact IBM Corporation, Department RM1A, 1000 N.W. 51st Street, Boca Raton, FL 33431, U.S.A. Such information may be available, subject to appropriate terms and conditions, including in some cases, payment of a fee.<P>
<B><P>
<H2>Trademarks</B></H2>
<P>
The following are trademarks of the IBM Corporation in the United States or other countries or both:<P>
<P>
AIX<P>
IBM<P>
OS/2<P>
SOM<P>
System Object Model<P>
Workplace Shell<P>
<P>
The following terms are trademarks of other companies:<P>
<P>
<TABLE BORDER=1><TD  VALIGN=TOP>Apple<TD  VALIGN=TOP>Apple Computer Inc.<TR>
<TD  VALIGN=TOP>C++<TD  VALIGN=TOP>AT&amp;T Company<TR>
<TD  VALIGN=TOP>CORBA<TD  VALIGN=TOP>Object Management Group, Inc.<TR>
<TD  VALIGN=TOP>Macintosh<TD  VALIGN=TOP>Apple Computer Inc.<TR>
<TD  VALIGN=TOP>Mac OS<TD  VALIGN=TOP>Apple Computer Inc.<TR>
<TD  VALIGN=TOP>Microsoft<TD  VALIGN=TOP>Microsoft Corporation<TR>
<TD  VALIGN=TOP>OpenDoc<TD  VALIGN=TOP>Apple Computer Inc.<TR>
<TD  VALIGN=TOP>QuickDraw<TD  VALIGN=TOP>Apple Computer Inc.<TR>
<TD  VALIGN=TOP>Windows<TD  VALIGN=TOP>Microsoft Corporation</TABLE>
<P>
All other marks are the property of their respective owners.
</BODY></HTML>