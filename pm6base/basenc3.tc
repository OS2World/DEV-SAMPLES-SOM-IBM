/*
    File:          $filename:toupper$.CPP

    Description:   Implementation of $partname$

    Written by:    $author$

    Copyright:     (c) $years$ by $company$
                   - all rights reserved

    Generated by:  $toolname$ $toolversion$
*/

#ifndef SOM_Module_$filename$_Source
#define SOM_Module_$filename$_Source
#endif
#define $partname$_Class_Source

#define VARIABLE_MACROS

#define INCL_GPI
#define INCL_ODAPI
#define INCL_ODARBITRATOR
#define INCL_ODCANVAS
#define INCL_ODDRAFT
#define INCL_ODERRORS
#define INCL_ODFACET
#define INCL_ODFRAME
#define INCL_ODMENUBAR
#define INCL_ODSESSION
#define INCL_ODSHAPE
#define INCL_ODSTORAGEUNIT
#define INCL_ODSTORAGEUNITVIEW
#define INCL_ODTRANSFORM
#define INCL_ODWINDOW
#define INCL_ODWINDOWSTATE
#include <os2.h>
#include <stdio.h>

#include "$filename$.xih"
#include <focuslib.h>

const ODType kPartHandlerName = "$partname$";
const ODType kDisplayName = $displayname$;
const ODType kKind = $kind$;
const ODType kKindDisplayName = $kinddisplayname$;
const ODType kCategory = $category$;
const ODType kCategoryDisplayName = $categorydisplayname$;

const char  *kDebugName = "$partname$";
const char  *kDebugNameM = "M_$partname$";

#define FIXED2LONG(f) (((f) + 0x8000) >> 16)

#ifdef DEBUG
    #undef $partname$MethodDebug
    #undef M_$partname$MethodDebug

    #define $partname$MethodDebug(x,y) LogString(somSelf,x,y)
    #define M_$partname$MethodDebug(x,y) LogString(somSelf,x,y)

    #include <log.h>
#endif


/*
    This is the first method called when an object of this class is created.
    Initialization of all attributes and private variables.

    Implementation: Call parent initializer, initialize attributes
    Return        : None
    Subclassing   : Call first
    Notes         : None
*/

SOM_Scope void SOMLINK somDefaultInit($partname$ *somSelf, somInitCtrl* ctrl)
{
    #ifdef DEBUG
      LogOpen (somSelf, "$filename$");
    #endif

    $partname$Data *somThis; /* set in BeginInitializer */
    somInitCtrl globalCtrl;
    somBooleanVector myMask;
    $partname$MethodDebug(kPartHandlerName,"somDefaultInit");
    $partname$_BeginInitializer_somDefaultInit;

    $partname$_Init_$parentname$_somDefaultInit(somSelf, ctrl);

    // initialization
    _text = NULL;
}

/*
    This is the last method called before this instance of the class is
    destroyed. Release any remaining allocated resources.

    Implementation: Clean up resources, then call parent
    Return        : None
    Subclassing   : Call last (or as your part requires)
    Notes         : None
*/

SOM_Scope void SOMLINK somDestruct($partname$ *somSelf, octet doFree, somDestructCtrl* ctrl)
{
    $partname$Data *somThis; /* set in BeginDestructor */
    somDestructCtrl globalCtrl;
    somBooleanVector myMask;
    $partname$MethodDebug(kPartHandlerName,"somDestruct");
    $partname$_BeginDestructor;

    // clean up
    if (_text != NULL)
        SOMFree (_text);

    $partname$_EndDestructor;
}

/*
    Return part kind string

    Implementation:
    Return        : None.
    Subclassing   : Must be implemented by derived class
    Notes         :
*/

SOM_Scope string  SOMLINK PartKind($partname$ *somSelf,  Environment *ev)
{
    $partname$Data *somThis = $partname$GetData(somSelf);
    $partname$MethodDebug(kPartHandlerName,"PartKind");

    return (kKind);
}

/*
    Initialization common to new and restored parts.

    Implementation:
    Return        : None.
    Subclassing   : Call parent at any point.
    Notes         :
*/

SOM_Scope void  SOMLINK InitializePart($partname$ *somSelf,  Environment *ev)
{
    $partname$Data *somThis = $partname$GetData(somSelf);
    $partname$MethodDebug(kPartHandlerName,"InitializePart");

    $partname$_parent_$parentname$_InitializePart(somSelf, ev);
}

SOM_Scope void  SOMLINK InitPart($partname$ *somSelf,  Environment *ev,
                                 ODStorageUnit* storageUnit, ODPart *partWrapper)
{
    $partname$Data *somThis = $partname$GetData(somSelf);
    $partname$MethodDebug(kPartHandlerName,"InitPart");

    $partname$_parent_$parentname$_InitPart(somSelf, ev, storageUnit, partWrapper);

    _text = (string) SOMMalloc (strlen ("$partname$") + 1);
    strcpy (_text, "$partname$");
}

SOM_Scope void  SOMLINK InitPartFromStorage($partname$ *somSelf, Environment *ev,
                                            ODStorageUnit* storageUnit, ODPart *partWrapper)
{
    $partname$Data *somThis = $partname$GetData(somSelf);
    $partname$MethodDebug(kPartHandlerName,"InitPartFromStorage");

    $partname$_parent_$parentname$_InitPartFromStorage(somSelf, ev, storageUnit, partWrapper);
}

SOM_Scope void  SOMLINK InternalizeContent($partname$ *somSelf,  Environment *ev, ODStorageUnit *storageUnit)
{
    $partname$Data *somThis = $partname$GetData(somSelf);
    $partname$MethodDebug(kPartHandlerName,"InternalizeContent");

    $partname$_parent_$parentname$_InternalizeContent(somSelf, ev, storageUnit);

    if (storageUnit->Exists (ev, "Text", kODISOStr, 0))
     {
        storageUnit->Focus (ev, "Text", kODPosUndefined, kODISOStr, 0, kODPosUndefined);
        unsigned long ulSize = storageUnit->GetSize (ev);
        _text = (string) SOMMalloc (ulSize);
        StorageUnitGetValue (storageUnit, ev, ulSize, _text);
     }
    else
     {
        _text = (string) SOMMalloc (strlen ("$partname$") + 1);
        strcpy (_text, "$partname$");
     }
}

SOM_Scope void  SOMLINK ExternalizeContent($partname$ *somSelf,  Environment *ev, ODStorageUnit *storageUnit)
{
    $partname$Data *somThis = $partname$GetData(somSelf);
    $partname$MethodDebug(kPartHandlerName,"ExternalizeContent");

    $partname$_parent_$parentname$_ExternalizeContent(somSelf, ev, storageUnit);

    if (storageUnit->Exists (ev, "Text", kODISOStr, 0) == kODFalse)
        storageUnit->AddProperty (ev, "Text")->AddValue (ev, kODISOStr);

    storageUnit->Focus (ev, "Text", kODPosUndefined, kODISOStr, 0, kODPosUndefined);
    StorageUnitSetValue (storageUnit, ev, strlen (_text) + 1, _text);
}

SOM_Scope void  SOMLINK DrawFrameView($partname$ *somSelf,  Environment *ev, ODFacet* facet, ODShape *invalidShape)
{
    $partname$Data *somThis = $partname$GetData(somSelf);
    $partname$MethodDebug(kPartHandlerName,"DrawFrameView");

    HPS hps;
    CFocus f (ev, facet, invalidShape, &hps);

    ODRect rect;
    RECTL  frameRect;

    ODShape *shape = facet->GetFrame (ev)->AcquireFrameShape (ev, facet->GetCanvas (ev));
    shape->GetBoundingBox (ev, &rect);
    frameRect.xLeft = FIXED2LONG (rect.left);
    frameRect.xRight = FIXED2LONG (rect.right);
    frameRect.yTop = FIXED2LONG (rect.top);
    frameRect.yBottom = FIXED2LONG (rect.bottom);

    GpiSetColor (hps, CLR_BLUE);
    GpiBox (hps, DRO_FILL, (PPOINTL) &frameRect.xRight, 0, 0);

    POINTL aptl[TXTBOX_COUNT];
    GpiQueryTextBox (hps, strlen (_text), _text, TXTBOX_COUNT, aptl);

    POINTL ptl;
    ptl.x = (frameRect.xRight - aptl[TXTBOX_TOPRIGHT].x) / 2;
    ptl.y = (frameRect.yTop - aptl[TXTBOX_TOPRIGHT].y) / 2;

    GpiSetColor (hps, CLR_WHITE);
    GpiCharStringAt (hps, &ptl, strlen (_text), _text);
}


// Menu framework methods

// Return indicates whether a copy operation is currently valid
SOM_Scope ODBoolean SOMLINK MenuCopyValid ($partname$ *somSelf,  Environment *ev)
{
    $partname$Data *somThis = $partname$GetData(somSelf);
    $partname$MethodDebug("$partname$","MenuCopyValid");

    return (kODTrue);
}

// Return indicates whether a paste operation is currently valid
SOM_Scope ODBoolean SOMLINK MenuPasteValid ($partname$ *somSelf,  Environment *ev, ODStorageUnit *su)
{
    $partname$Data *somThis = $partname$GetData(somSelf);
    $partname$MethodDebug("$partname$","MenuPasteValid");

    return (kODTrue);
}

// When the user executes a copy operation, the storageunit to be placed on
// the clipboard must be populated, or a promise made.
SOM_Scope void SOMLINK PopulateClipboardStorageUnit ($partname$ *somSelf,  Environment *ev, ODStorageUnit *su)
{
    $partname$Data *somThis = $partname$GetData(somSelf);
    $partname$MethodDebug("$partname$","PopulateClipboardStorageUnit");

    su->AddProperty (ev, kODPropContents)->AddValue (ev, kODKindPlainText);
    StorageUnitSetValue (su, ev, strlen (_text) + 1, _text);
}

// When the user executes a paste operation, this method will receive the
// storageunit from the clipboard.
SOM_Scope void SOMLINK ReceiveClipboardStorageUnit ($partname$ *somSelf,  Environment *ev, ODStorageUnit *su)
{
    $partname$Data *somThis = $partname$GetData(somSelf);
    $partname$MethodDebug("$partname$","ReceiveClipboardStorageUnit");

    // check if clipboard text type available from storage unit
    if (su->Exists (ev, kODPropContents, kODKindPlainText, 0))
     {
        // get data from storage unit, qualify length to valid symbol length
        su->Focus (ev, kODPropContents, kODPosUndefined, kODKindPlainText, 0, kODPosUndefined);
        ULONG ulSize = su->GetSize (ev);
        _text = (string) SOMRealloc (_text, ulSize);
        StorageUnitGetValue (su, ev, ulSize, _text);

        somSelf->InvalidateAllFacets (ev);
        somSelf->SetContentChanged (ev);

        somSelf->UpdateLink (ev);
     }
}


// Drag and Drop framework methods

// Return indicates whether a drag operation is currently valid
SOM_Scope ODBoolean SOMLINK DragValid ($partname$ *somSelf, Environment *ev)
{
    $partname$Data *somThis = $partname$GetData(somSelf);
    $partname$MethodDebug("$partname$","DragVa3id");

    return (kODTrue);
}

// Return indicates where a3drop operation is currently valid, the dragInfo
// param may be used to look at the current drag object to determine whether
// the drag content is suitable for dropping
SOM_Scope ODBoolean SOMLINK DropValid ($partname$ *somSelf, Environment *ev, ODDragItemIterator *dragInfo)
{
    $partname$Data *somThis = $partname$GetData(somSelf);
    $partname$MethodDebug("$partname$","DropValid");

    return (kODTrue);
}

// When the user starts the drag operation, the storageunit to be dragged
// must be populated, or a promise made.
SOM_Scope void SOMLINK PopulateDragStorageUnit ($partname$ *somSelf, Environment *ev, ODStorageUnit *su)
{
    $partname$Data *somThis = $partname$GetData(somSelf);
    $partname$MethodDebug("$partname$","PopulateDragStorageUnit");

    su->AddProperty (ev, kODPropContents)->AddValue (ev, kODKindPlainText);
    StorageUnitSetValue (su, ev, strlen (_text) + 1, _text);
}

// When the user drops the object, this method will receive the storageunit
// associated with the drop object. In this case, the dropped storageunit is
// managed in the same way as a Paste operation, and the equivalent clipboard
// operation is used.
SOM_Scope ODDropResult SOMLINK ReceiveDropStorageUnit ($partname$ *somSelf,  Environment *ev, ODStorageUnit *su, ODFacet *facet, ODPoint *where)
{
    $partname$Data *somThis = $partname$GetData(somSelf);
    $partname$MethodDebug("$partname$","ReceiveDropStorageUnit");

    somSelf->ReceiveClipboardStorageUnit (ev, su);
    return (kODDropCopy);
}


// Link Source framework methods

// Return indicates whether a copy operation should include posting a link
// specification on the clipboard
SOM_Scope ODBoolean SOMLINK LinkSourceValid ($partname$ *somSelf,  Environment *ev)
{
    $partname$Data *somThis = $partname$GetData(somSelf);
    $partname$MethodDebug("$partname$","LinkSourceValid");

    return (kODTrue);
}

// When the link is to be updated (this part may call UpdateLink which will
// dispatch this method), populate the storage unit to be distributed.
SOM_Scope void SOMLINK PopulateLinkStorageUnit ($partname$ *somSelf,  Environment *ev, ODStorageUnit *su)
{
    $partname$Data *somThis = $partname$GetData(somSelf);
    $partname$MethodDebug("$partname$","PopulateLinkStorageUnit");

    // place current symbol name on clipboard as clipboard text type
    su->AddProperty (ev, kODPropContents)->AddValue (ev, kODKindPlainText);
    StorageUnitSetValue (su, ev, strlen (_text) + 1, _text);
}

// metaclass methods

SOM_Scope ISOString  SOMLINK clsGetODPartHandlerName(M_$partname$ *somSelf,
                                                     Environment *ev)
{
    /* M_$partname$Data *somThis = M_$partname$GetData(somSelf); */
    M_$partname$MethodDebug(kDebugNameM,"clsGetODPartHandlerName");

    ISOString handlerName = (ISOString) SOMMalloc (strlen (kPartHandlerName) + 1);
    strcpy (handlerName, kPartHandlerName);
    return (handlerName);
}

SOM_Scope string  SOMLINK clsGetODPartHandlerDisplayName(M_$partname$ *somSelf,
                                                         Environment *ev)
{
    /* M_$partname$Data *somThis = M_$partname$GetData(somSelf); */
    M_$partname$MethodDebug(kDebugNameM,"clsGetODPartHandlerDisplayName");

    string displayName = (string) SOMMalloc (strlen (kDisplayName) + 1);
    strcpy (displayName, kDisplayName);
    return (displayName);
}

SOM_Scope _IDL_SEQUENCE_PartKindInfo  SOMLINK clsGetODPartKinds(M_$partname$ *somSelf,
                                                                             Environment *ev)
{
    /* M_$partname$Data *somThis = M_$partname$GetData(somSelf); */
    M_$partname$MethodDebug(kDebugNameM,"clsGetODPartKinds");

    _IDL_SEQUENCE_PartKindInfo kindInfo;

    // Create structure PartKindInfo  and allocate memory for variable
    PartKindInfo *info = (PartKindInfo *) SOMMalloc (sizeof (PartKindInfo));
    info->partKindName = (ISOString) SOMMalloc (strlen (kKind) + 1);
    info->partKindDisplayName = (string) SOMMalloc (strlen (kKindDisplayName) + 1);
    info->filenameFilters =  (string) SOMMalloc (strlen ("") + 1);
    info->filenameTypes =  (string) SOMMalloc (strlen ("") + 1);
    info->categories =  (string) SOMMalloc (strlen (kCategory) + 1);
    info->categoryDisplayName =  (string) SOMMalloc (strlen (kCategoryDisplayName) + 1);
    info->objectID =  (string) SOMMalloc (strlen ("") + 1);

    // Copy the information into the structure
    strcpy (info->partKindName, kKind);
    strcpy (info->partKindDisplayName, kKindDisplayName);
    strcpy (info->filenameFilters, "");
    strcpy (info->filenameTypes, "");
    strcpy (info->categories, kCategory);
    strcpy (info->categoryDisplayName, kCategoryDisplayName);
    strcpy (info->objectID, "");

    kindInfo._maximum = 1;
    kindInfo._length = 1;
    kindInfo._buffer = info;

    return (kindInfo);
}

SOM_Scope string  SOMLINK clsGetOLE2ClassId(M_$partname$ *somSelf,
                                                         Environment *ev)
{
    /* M_$partname$Data *somThis = M_$partname$GetData(somSelf); */
    M_$partname$MethodDebug(kDebugNameM,"clsGetOLE2ClassId");

    string classID = (string) SOMMalloc (1);
    classID[0] = '\0';
    return (classID);
}

SOM_Scope string  SOMLINK clsGetWindowsIconFileName(M_$partname$ *somSelf,
                                                                 Environment *ev)
{
    /* M_$partname$Data *somThis = M_$partname$GetData(somSelf); */
    M_$partname$MethodDebug(kDebugNameM,"clsGetWindowsIconFileName");

    string fileName = (string) SOMMalloc (1);
    fileName[0] = '\0';
    return (fileName);
}


#ifdef __IBMC___
  #pragma linkage (SOMInitModule, system)
#endif

SOMEXTERN void SOMLINK SOMInitModule (long majorVersion, long minorVersion,
                                 string className)
{
   $partname$NewClass ($partname$_MajorVersion, $partname$_MinorVersion);
}
